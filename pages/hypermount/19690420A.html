<!DOCTYPE html>
<meta charset='UTF-8'>
<title>/</title>
<link href='../../styles/layout.css' rel='stylesheet'>
<style>td:nth-child(1){width:45%}</style>
<script src='../../scripts/core.js'></script>
<script src='../../scripts/highlighting.js'></script>
<article>
	<header>
		<h1>物件程式庫</h1>
		<p>
			<a href='#array'>Array</a>、<a href='#boolean'>Boolean</a>、<a href='#function'>Function</a>、<a href='#number'>Number</a>、<a href='#object'>Object</a>、<a href='#string'>String</a><br>
			<a href='#date'>Date</a>、<a href='#json'>JSON</a>、<a href='#map'>Map</a>、<a href='#math'>Math</a>、<a href='#promise'>Promise</a>、<a href='#regexp'>RegExp</a>、<a href='#set'>Set</a><br>
			<a href='#av'>Audio</a>、<a href='#canvas'>Canvas</a>、<a href='#url'>URL</a>、<a href='#av'>Video</a>
		</p>
	</header>
	<hr id='array'>
	<section>
		<h2>Array</h2>
		<p>
			Array 物件是 JavaScript 提供「陣列」資料結構的解決方案。雖然採行這樣的方式，只能建立一維陣列，但還是可以對陣列產生陣列的方式，來實現多維陣列的設計。
		</p>
		<table>
			<tr><td>at(索引)</td><td>取得第幾筆資料，可用負數表示尾端資料。</td></tr>
			<tr><td>concat(元素1,元素2,…)</td><td>將其它陣列或資料加入陣列。</td></tr>
			<tr><td>entries()</td><td>取得索引和資料。</td></tr>
			<tr><td>fill(資料,[開始位置,結束位置])</td><td>填滿資料。</td></tr>
			<tr><td>includes(資料)</td><td>檢查是否有資料。</td></tr>
			<tr><td>indexOf(資料)</td><td>搜尋資料位置。</td></tr>
			<tr><td>join(符號)</td><td>以符號為區隔，輸出陣列資料。參數省略的話預設為 , 逗號。</td></tr>
			<tr><td>keys()</td><td>取得所有索引編號。</td></tr>
			<tr><td>lastIndexOf(資料)</td><td>從陣列結尾搜尋資料位置。</td></tr>
			<tr><td>length</td><td>取得資料的筆數。</td></tr>
			<tr><td>pop()</td><td>移除最後一筆資料。</td></tr>
			<tr><td>push(資料1,資料2,…)</td><td>在陣列末端加入新的資料。</td></tr>
			<tr><td>reverse()</td><td>顛倒陣列資料的排列順序。</td></tr>
			<tr><td>shift()</td><td>移除第一筆資料。</td></tr>
			<tr><td>slice(開始位置[,結束位置])</td><td>傳回擷取範圍內的資料，可用負數表示尾端資料。</td></tr>
			<tr><td>sort()</td><td>進行排序。</td></tr>
			<tr><td>splice(位置,數量,資料)</td><td>隨參數不同，進行移除、插入、取代資料不同動作。</td></tr>
			<tr><td>toReversed()</td><td>傳回顛倒順序的陣列資料。</td></tr>
			<tr><td>toSorted()</td><td>傳回排序的陣列資料。</td></tr>
			<tr><td>toSpliced(位置,數量,資料)</td><td>傳回 splice 過的資料。</td></tr>
			<tr><td>unshift(資料1,資料2,…)</td><td>在陣列開頭加入新的資料。</td></tr>
			<tr><td>values()</td><td>傳回所有資料。</td></tr>
			<tr><td>Array.isArray(陣列)</td><td>檢查是否為陣列。</td></tr>
			<tr><td>Array.of(資料,資料,…)</td><td>將所有參數資料匯集成陣列。</td></tr>
			<tr><td>Array.from(資料)</td><td>將傳入的一筆資料解析為陣列資料。</td></tr>
		</table>
		<p>
			這裡只列出操作陣列物件的功能，並未列出 ECMAScript 5 以後追加的一系列函數式設計功能！因為這些功能很難說明，要看範例才知道在做什麼，所以請進一步看 <a href='http://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array'>MDN</a> 的文件，熟悉這些能提升資料結構與演算法的開發效率。
		</p>
	</section>
	<hr id='av'>
	<section>
		<h2>Audio and Video</h2>
		<p>
			對應 HTML5 的 Audio 和 Video 標籤，兩者使用一樣的 API 來控制播放音樂和影片的功能。
		</p>
		<table>
			<tr><td>addTextTrack(類型,標題,語言)</td><td>向影音添加新的字軌，類型有：subtitles、caption、descriptions、chapters、metadata。</td></tr>
			<tr><td>audioTracks</td><td>表示可用音軌的 AudioTrackList 物件。</td></tr>
			<tr><td>autoplay</td><td>是否在加載完成後隨即播放影音。</td></tr>
			<tr><td>buffered</td><td>表示影音已緩衝部分的 TimeRanges 物件。</td></tr>
			<tr><td>canPlayType(類型)</td><td>檢查瀏覽器是否能播放指定的影音類型，類型有：video/ogg、video/mp4、video/webm、audio/mpeg、audio/ogg、audio/mp4。</td></tr>
			<tr><td>controller</td><td>表示影音當前媒體控制器的 MediaController 物件。</td></tr>
			<tr><td>controls</td><td>影音是否顯示控制項。</td></tr>
			<tr><td>crossOrigin</td><td>影音的 CORS 設定。</td></tr>
			<tr><td>currentSrc</td><td>當前影音的 URL。</td></tr>
			<tr><td>currentTime</td><td>影音中的當前播放位置，以秒計。</td></tr>
			<tr><td>defaultMuted</td><td>影音默認是否靜音。</td></tr>
			<tr><td>defaultPlaybackRate</td><td>影音的默認播放速度。</td></tr>
			<tr><td>duration</td><td>當前影音的長度，以秒計。</td></tr>
			<tr><td>ended</td><td>影音的播放是否已結束。</td></tr>
			<tr><td>error</td><td>表示影音錯誤狀態的 MediaError 物件。</td></tr>
			<tr><td>load()</td><td>重新加載影音元素。</td></tr>
			<tr><td>loop</td><td>影音是否應在結束時重新播放。</td></tr>
			<tr><td>mediaGroup</td><td>影音所屬的組合，用於連接多個影音元素。</td></tr>
			<tr><td>muted</td><td>影音是否靜音。</td></tr>
			<tr><td>networkState</td><td>影音的當前網絡狀態。</td></tr>
			<tr><td>paused</td><td>影音是否暫停。</td></tr>
			<tr><td>pause()</td><td>暫停當前播放的影音。</td></tr>
			<tr><td>play()</td><td>開始播放影音。</td></tr>
			<tr><td>playbackRate</td><td>影音播放的速度。</td></tr>
			<tr><td>played</td><td>表示影音已播放部分的 TimeRanges 物件。</td></tr>
			<tr><td>preload</td><td>影音是否應該在頁面加載後進行加載。（通常用 auto）</td></tr>
			<tr><td>readyState</td><td>影音當前的就緒狀態。</td></tr>
			<tr><td>seekable</td><td>表示影音可尋址部分的 TimeRanges 物件。</td></tr>
			<tr><td>seeking</td><td>用戶是否正在影音中進行查找。</td></tr>
			<tr><td>src</td><td>影音元素的當前來源。</td></tr>
			<tr><td>startDate</td><td>表示當前時間偏移的 Date 物件。</td></tr>
			<tr><td>textTracks</td><td>表示可用字軌的 TextTrackList 物件。</td></tr>
			<tr><td>videoTracks</td><td>表示可用視軌的 VideoTrackList 物件。</td></tr>
			<tr><td>volume</td><td>影音的音量。</td></tr>
		</table>
		<p>
			事件：
		</p>
		<table>
			<tr><td>abort</td><td>影音的加載已放棄時。</td></tr>
			<tr><td>canplay</td><td>瀏覽器可以播放影音時。</td></tr>
			<tr><td>canplaythrough</td><td>瀏覽器可在不因緩衝而停頓的情況下進行播放時。</td></tr>
			<tr><td>durationchange</td><td>影音的時長已更改時。</td></tr>
			<tr><td>emptied</td><td>目前的播放列表為空時。</td></tr>
			<tr><td>ended</td><td>目前的播放列表已結束時。</td></tr>
			<tr><td>error</td><td>在影音加載期間發生錯誤時。</td></tr>
			<tr><td>loadeddata</td><td>瀏覽器已加載影音的當前幀時。</td></tr>
			<tr><td>loadedmetadata</td><td>瀏覽器已加載影音的元數據時。</td></tr>
			<tr><td>loadstart</td><td>瀏覽器開始查找影音時。</td></tr>
			<tr><td>pause</td><td>影音已暫停時。</td></tr>
			<tr><td>play</td><td>影音已開始或不再暫停時。</td></tr>
			<tr><td>playing</td><td>影音在已因緩衝而暫停或停止後已就緒時。</td></tr>
			<tr><td>progress</td><td>瀏覽器正在下載影音時。</td></tr>
			<tr><td>ratechange</td><td>影音的播放速度已更改時。</td></tr>
			<tr><td>seeked</td><td>用戶已移動到影音中的新位置時。</td></tr>
			<tr><td>seeking</td><td>用戶開始移動到影音中的新位置時。</td></tr>
			<tr><td>stalled</td><td>瀏覽器嘗試獲取媒體數據，但數據不可用時。</td></tr>
			<tr><td>suspend</td><td>瀏覽器刻意不獲取媒體數據時。</td></tr>
			<tr><td>timeupdate</td><td>目前的播放位置已更改時。</td></tr>
			<tr><td>volumechange</td><td>音量已更改時。</td></tr>
			<tr><td>waiting</td><td>視頻由於需要緩衝下一幀而停止時。</td></tr>
		</table>
	</section>
	<hr id='boolean'>
	<section>
		<h2>Boolean</h2>
		<p>
			Boolean 物件用來表示 true 與 false 兩種值的資料。<br>
			<br>
			它只有繼承自 Object 的 toString() 和 valueOf(物件) 兩個功能，前者以字串輸出 Boolean 物件的資料，後者將物件轉換為 Boolean 物件的資料。
		</p>
	</section>
	<hr id='canvas'>
	<section>
		<h2>Canvas</h2>
		<p>
			對應 HTML5 的 Canvas 標籤，用來表示繪圖區域。
		</p>
		<table>
			<tr><td>height</td><td>高度</td></tr>
			<tr><td>width</td><td>寬度</td></tr>
			<tr><td>getContext('2D')</td><td>取得 CanvasRenderlingContext2D 物件。</td></tr>
			<tr><td>toDataURL([type], ..args)</td><td>將圖像轉換成 base 64 編碼。</td></tr>
		</table>
		<p>
			對 JavaScript 來說，重點是取得 CanvasRenderlingContext2D 物件後，用它來進行繪圖，有如下屬性：
		</p>
		<table>
			<tr><td>data</td><td>ImageData 物件，用於像素處理。</td></tr>
			<tr><td>fillStyle</td><td>填充的顏色。</td></tr>
			<tr><td>font</td><td>文字的粗斜、大小、字型，用法跟 CSS 一樣。</td></tr>
			<tr><td>globalAlpha</td><td>當前 alpha 值。</td></tr>
			<tr><td>globalCompositeOperation</td><td>新圖像如何繪製到已有的圖像上：source-over、source-atop、source-in、source-out、destination-over、destination-atop、destination-in、destination-out、lighter、copy、source-over。</td></tr>
			<tr><td>lineCap</td><td>線條的結束端點樣式：butt、round、square。</td></tr>
			<tr><td>lineJoin</td><td>兩條線相交時，所建立的拐角類型：miter、bevel、round。</td></tr>
			<tr><td>lineWidth</td><td>線條寬度。</td></tr>
			<tr><td>miterLimit</td><td>最大斜接長度。</td></tr>
			<tr><td>shadowBlur</td><td>陰影的模糊級別。</td></tr>
			<tr><td>shadowColor</td><td>陰影的顏色。</td></tr>
			<tr><td>shadowOffsetX</td><td>陰影距形狀的水平距離。</td></tr>
			<tr><td>shadowOffsetY</td><td>陰影距形狀的垂直距離。</td></tr>
			<tr><td>strokeStyle</td><td>線條的顏色。</td></tr>
			<tr><td>textAlign</td><td>文字內容的當前對齊方式：start、end、center、left、right。</td></tr>
			<tr><td>textBaseline</td><td>在繪製文字時使用的當前文字基線：alphabetic、top、hanging、middle、ideographic、bottom。</td></tr>
		</table>
		<p>
			以及如下方法：
		</p>
		<table>
			<tr><td>addColorStop(stop,color)</td><td>規定漸變對像中的顏色和停止位置。</td></tr>
			<tr><td>arc(x,y,r,a1,a2,c)</td><td>繪製圓弧，r 為半徑，a1 a2 為弧角的起始和結束，c 為 true 表示逆時針。</td></tr>
			<tr><td>arcTo(x,y,x2,y2,r)</td><td>繪製兩切線之間的圓弧。</td></tr>
			<tr><td>beginPath()</td><td>開始繪製路徑。</td></tr>
			<tr><td>bezierCurveTo(x,y,x2,y2,x3,y3)</td><td>繪製貝斯曲線。</td></tr>
			<tr><td>clearRect(x,y,w,h)</td><td>清除矩形內的圖像。</td></tr>
			<tr><td>clip()</td><td>從原始畫布剪切任意形狀和尺寸的區域。</td></tr>
			<tr><td>closePath()</td><td>結束繪製路徑。</td></tr>
			<tr><td>createImageData(w,h)</td><td>建立新的 ImageData 物件。</td></tr>
			<tr><td>createLinearGradient(x,y,x2,y2)</td><td>建立線性漸變。</td></tr>
			<tr><td>createPattern(image,pattern)</td><td>指定貼圖的模式：repeat、repeat-x、repeat-y、no-repeat。</td></tr>
			<tr><td style='font-size:10px'>createRadialGradient(x,y,r,x2,y2,r2)</td><td>建立放射狀或環形的漸變。</td></tr>
			<tr><td>drawImage(image,x,y)</td><td>在畫布上繪製圖像、畫布或視頻。</td></tr>
			<tr><td>fillRect(x,y,w,h)</td><td>繪製有填色的矩形。</td></tr>
			<tr><td>fillText(text,x,y,w)</td><td>在畫布上繪製文字。</td></tr>
			<tr><td>fill()</td><td>填色。</td></tr>
			<tr><td>getImageData(x,y,w,h)</td><td>將畫布指定矩形範圍內的圖像輸出為 ImageData 物件。</td></tr>
			<tr><td>isPointInPath(x,y)</td><td>如果指定的點位於當前路徑中傳回 true，否則 false。</td></tr>
			<tr><td>lineTo(x,y)</td><td>添加一個新點，然後在畫布中建立從該點到最後指定點的線條。</td></tr>
			<tr><td>measureText(text)</td><td>傳回指定文字寬度的物件。</td></tr>
			<tr><td>moveTo(x,y)</td><td>把路徑移動到畫布中的指定點，不建立線條。</td></tr>
			<tr><td>putImageData(ImageData,x,y)</td><td>將 ImageData 貼到畫布位置上。</td></tr>
			<tr><td>quadraticCurveTo(x,y,x2,y2)</td><td>繪製曲線。</td></tr>
			<tr><td>rect(x,y,w,h)</td><td>建立矩形。</td></tr>
			<tr><td>restore()</td><td>復原畫布。</td></tr>
			<tr><td>rotate(a)</td><td>旋轉圖像。</td></tr>
			<tr><td>roundRect(x,y,w,h,r)</td><td>建立圓角矩形。</td></tr>
			<tr><td>save()</td><td>保存畫布。</td></tr>
			<tr><td>scale(w,h)</td><td>縮放圖像。</td></tr>
			<tr><td>setTransform(a,b,c,d,e,f)</td><td>重製矩陣，然後執行 transform()。</td></tr>
			<tr><td>stroke()</td><td>繪製路徑。</td></tr>
			<tr><td>strokeRect(x,y,w,h)</td><td>繪製矩形。</td></tr>
			<tr><td>strokeText(text,x,y,w)</td><td>在畫布上繪製外框文字。</td></tr>
			<tr><td>toDataURL()</td><td>將畫布以 base64 編碼的 PNG 圖檔輸出。可輸入選擇性參數 'image/jpeg' 變成 JPEG 圖檔。</td></tr>
			<tr><td>translate(x,y)</td><td>移動圖像位置。</td></tr>
			<tr><td>transform(a,b,c,d,e,f)</td><td>將圖像轉換為矩陣。</td></tr>
		</table>
		<p>
			雖然 HTML5 提供了這套 API，但沒有 GDI 電腦繪圖專業的一般人很難活用它，不花個一年半載鑽研，沒辦法藉由 Canvas 做出什麼成效來。所以在這套 API 遇到挫折不要氣餒，循序漸進一步步學成相關技術就好。<br>
			<br>
			你可以透過以下章節初步了解 Canvas API 的使用情況：<a href='19690511A.html'>貼圖 (Draw pictures)</a>、<a href='19690518A.html'>連續圖像 (Sprite)</a>、<a href='19690525A.html'>雙重緩衝 (Double Buffer)</a>、<a href='19690601A.html'>翻頁 (Page Flipping)</a>、影格 (Frame)、圖磚 (Tile)，雖然無法因此成為圖形裝置電腦繪圖技術的專業，但在循序漸進的這條路上應該會有幫助。
		</p>
	</section>
	<hr id='date'>
	<section>
		<h2>Date</h2>
		<p>
			Date 物件提供處理日期與時間的功能。<br>
			<br>
			然而，取得的是使用者電腦所設定的時間，所以不見得是現實生活的準確時間。
		</p>
		<table>
			<tr><td>getDate()</td><td>取得日期。</td></tr>
			<tr><td>getDay()</td><td>取得星期。</td></tr>
			<tr><td>getFullYear()</td><td>取得完整四位數的西元年份。</td></tr>
			<tr><td>getHours()</td><td>取得小時。</td></tr>
			<tr><td>getMilliseconds()</td><td>取得毫秒；一秒等於 1000 毫秒。</td></tr>
			<tr><td>getMinutes()</td><td>取得分鐘。</td></tr>
			<tr><td>getMonth()</td><td>取得月份。</td></tr>
			<tr><td>getSeconds()</td><td>取得秒數。</td></tr>
			<tr><td>getTime()</td><td>計算自 1970 年 1 月 1 日 0 點 0 分至今所經過的毫秒數。</td></tr>
			<tr><td>getTimezoneOffset()</td><td>取得當地時區和格林威治時間的時差，以分鐘計算。</td></tr>
			<tr><td>getUTCDate()</td><td>以國際協定時間的格式取得日期。</td></tr>
			<tr><td>getUTCDay()</td><td>以國際協定時間的格式取得星期。</td></tr>
			<tr><td>getUTCFullYear()</td><td>以國際協定時間的格式取得年份。</td></tr>
			<tr><td>getUTCHours()</td><td>以國際協定時間的格式取得小時。</td></tr>
			<tr><td>getUTCMilliseconds()</td><td>以國際協定時間的格式取得毫秒。</td></tr>
			<tr><td>getUTCMinutes()</td><td>以國際協定時間的格式取得分鐘。</td></tr>
			<tr><td>getUTCMonth()</td><td>以國際協定時間的格式取得月份。</td></tr>
			<tr><td>getUTCSeconds()</td><td>以國際協定時間的格式取得秒數。</td></tr>
			<tr><td>getYear()</td><td>取得年份。採用 19XX 尾數的方式，已不被建議使用。</td></tr>
			<tr><td>setDate(日)</td><td>設定日期。</td></tr>
			<tr><td>setFullYear(年)</td><td>設定完整四位數的西元年份。</td></tr>
			<tr><td>setHours(時,分,秒,毫秒)</td><td>設定小時。後面參數可同時設定完整的時間，可省略。</td></tr>
			<tr><td>setMilliseconds(毫秒)</td><td>設定毫秒，注意數值範圍從 0 到 999。</td></tr>
			<tr><td>setMinutes(分,秒,毫秒)</td><td>設定分鐘。後面的參數可同時設定秒數，可省略。</td></tr>
			<tr><td>setMonth(月,日)</td><td>設定月份。後面的參數可同時設定日期，可省略。</td></tr>
			<tr><td>setSeconds(秒,毫秒)</td><td>設定秒數。後面的參數可同時設定毫秒，可省略。</td></tr>
			<tr><td>setTime()</td><td>設定自 1970 年 1 月 1 日 0 點 0 分至指定日期所經過的毫秒數。</td></tr>
			<tr><td>setUTCDate(日)</td><td>可以輸入完整的國際協定時間格式來設定日期。</td></tr>
			<tr><td>setUTCFullYear(年)</td><td>可以輸入完整的國際協定時間格式來設定年份。</td></tr>
			<tr><td>setUTCHours(時)</td><td>可以輸入完整的國際協定時間格式來設定小時。</td></tr>
			<tr><td>setUTCMilliseconds(毫秒)</td><td>可以輸入完整的國際協定時間格式來設定毫秒。</td></tr>
			<tr><td>setUTCMinutes(分)</td><td>可以輸入完整的國際協定時間格式來設定分鐘。</td></tr>
			<tr><td>setUTCMonth(月)</td><td>可以輸入完整的國際協定時間格式來設定月份。</td></tr>
			<tr><td>setUTCSeconds(秒)</td><td>可以輸入完整的國際協定時間格式來設定秒數。</td></tr>
			<tr><td>setYear(19XX 年的尾數)</td><td>採用 19XX 尾數的方式來設定年份，已不被建議使用。</td></tr>
			<tr><td>toDateString()</td><td>輸出日期。</td></tr>
			<tr><td>toGMTString()</td><td>以格林威治平均時間格式輸出完整日期與時間。</td></tr>
			<tr><td>toISOString()</td><td>以 ISO 的格式輸出完整日期與時間。</td></tr>
			<tr><td>toJSON()</td><td>將時間值以 JSON 字串輸出。</td></tr>
			<tr><td>toLocaleDateString()</td><td>以作業系統的本地時間格式輸出日期。</td></tr>
			<tr><td>toLocaleTimeString()</td><td>以作業系統的本地時間格式輸出時間。</td></tr>
			<tr><td>toLocaleString()</td><td>以作業系統的本地時間格式輸出字串。</td></tr>
			<tr><td>toTimeString()</td><td>輸出時間。</td></tr>
			<tr><td>toUTCString()</td><td>以國際協定時間的格式輸出完整日期與時間。</td></tr>
			<tr><td>Date(年,月,日,時,分,秒,毫秒)</td><td>依參數建立時間值，可省略後面沒用到的參數。</td></tr>
			<tr><td>Date.now()</td><td>傳回 POSIX 時間的毫秒數。</td></tr>
			<tr><td>Date.parse(字串)</td><td>剖析字串中的格式，轉為時間值。</td></tr>
			<tr><td>Date.UTC(年,月,日,時,分,秒,毫秒)</td><td>產生 POSIX 時間的毫秒數。</td></tr>
		</table>
		<p>
			new Date() 不輸入參數，會以當下時間為參數。<br>
			<br>
			輸入字串當時間，格式就像 1995-12-04T12:34:56，依此類推。<br>
			<br>
			在設定為台北地區的作業系統使用 getTimezoneOffset()，會傳回 -480 分鐘，也就是慢八小時的意思。
		</p>
	</section>
	<hr id='function'>
	<section>
		<h2>Function</h2>
		<p>
			JavaScript 把 function（函式）設計為 first class object（第一級物件），所有函式都是 Function 物件，而且是最高層級的型別，能夠當作參數傳遞！
		</p>
		<table>
			<tr><td>apply(指標,參數群)</td><td>代入指標與 arguments 給函式來使用物件。</td></tr>
			<tr><td>arguments</td><td>這是個物件，可以更多元地處理傳進來的參數，但是只能在函式內部使用。</td></tr>
			<tr><td>bind(指標,參數群)</td><td>產生新的函式並附加到指標的 method。</td></tr>
			<tr><td>call(指標,參數1,參數2,…)</td><td>調用函式，但 this 為傳入的指標。</td></tr>
			<tr><td>length</td><td>傳回參數的個數。</td></tr>
		</table>
		<p>
			call 其實就跟正常呼叫函式一樣，只是能指定 this 的接收者。<br>
			<br>
			apply 可以把多個參數的函式，改用陣列替代，變成只需一個參數就好。它的用途不是指定 this 的接收者，所以接收者通常設為 null。<br>
			<br>
			bind 不是呼叫函式，而是將函式建立成一個新的 function 物件給接收者，就像接收者自己有了這個方法一樣。通常用在傳入匿名函式參數的場合，也就是把 bind 出來的 function 物件當匿名函式傳入參數。
		</p>
	</section>
	<hr id='json'>
	<section>
		<h2>JSON</h2>
		<p>
			藉由 eval() 能執行字串中的程式，讓 JavaScript 能將物件轉為字串保存起來，日後再從字串轉為物件，所規範出來的資料格式，全文為 JavaScript Object Notation。
		</p>
		<table>
			<tr><td>JSON.parse(字串)</td><td>將 JSON 轉為物件</td></tr>
			<tr><td>JSON.stringify(物件)</td><td>將物件轉為 JSON</td></tr>
		</table>
		<p>
			如果你不知道這是怎麼回事，來看範例：<br>
			<br>
			<textarea class='brush:js'>
				//建立一個物件
				let player={
					name:'Twideem Civs',
					number:58
				};

				//轉為 JSON
				let json=JSON.stringify(player);
				document.write(json);
            </textarea>
			<br>
			<output>
				{"name":"Twideem Civs","number":58}
			</output>
			<br>
			接續上面的範例，現在還原 json 字串為另一個新的物件：<br>
			<br>
			<textarea class='brush:js'>
				//將 JSON 建立為新的第二個物件
				let oldboy=JSON.parse(json);

				//輸出新物件的屬性值
				document.write(oldboy.name);
				document.write(oldboy.email);
            </textarea>
			<br>
			<output>
				Twideem Civs<br>
				twideem@outlook.com
			</output>
			<br>
			字串很容易寫在檔案保存起來，有了 JSON 等於 JavaScript 有了序列化的機制。
		</p>
	</section>
	<hr id='map'>
	<section>
		<h2>Map</h2>
		<p>
			鍵值對資料結構，與 Object 的差別在於照 set() 資料的順序排列資料，不會排序，且迭代性能提高。
		</p>
		<table>
			<tr><td>clear()</td><td>清除所有資料。</td></tr>
			<tr><td>delete(鍵)</td><td>刪除一筆資料。</td></tr>
			<tr><td>entries()</td><td>以 Iterator 傳回所有名稱與資料。</td></tr>
			<tr><td>forEach(回呼函式)</td><td>隨資料的列舉過程執行程式功能。</td></tr>
			<tr><td>get(鍵)</td><td>取得資料。</td></tr>
			<tr><td>has(鍵)</td><td>檢查是否有某筆資料。</td></tr>
			<tr><td>keys()</td><td>以 Iterator 傳回所有名稱。</td></tr>
			<tr><td>set(鍵,值)</td><td>加入資料。</td></tr>
			<tr><td>size</td><td>取得資料筆數。</td></tr>
			<tr><td>values()</td><td>以 Iterator 傳回所有資料。</td></tr>
			<tr><td>Map.groupBy(項目,回呼函式)</td><td>分組資料。</td></tr>
		</table>
	</section>
	<hr id='math'>
	<section>
		<h2>Math</h2>
		<p>
			Math 是適合用來做數學運算的物件。特別的是，Math 物件不能使用 new 來建立，必須直接呼叫它的函數與常數。
		</p>
		<table>
			<tr><td>Math.abs(x)</td><td>絕對值。</td></tr>
			<tr><td>Math.acos(x)</td><td>反餘弦。</td></tr>
			<tr><td>Math.acosh(x)</td><td>雙曲反餘弦。</td></tr>
			<tr><td>Math.asin(x)</td><td>反正弦。</td></tr>
			<tr><td>Math.asinh(x)</td><td>雙曲反正弦。</td></tr>
			<tr><td>Math.atan(x)</td><td>反正切。</td></tr>
			<tr><td>Math.atan2(x,y)</td><td>傳回從X軸到點 (X,Y) 的角度。</td></tr>
			<tr><td>Math.atanh()</td><td>雙曲反正切。</td></tr>
			<tr><td>Math.cbrt(x)</td><td>立方根。</td></tr>
			<tr><td>Math.ceil(x)</td><td>無條件進位。</td></tr>
			<tr><td>Math.clz32(x)</td><td>轉為 32 位數二進制值。</td></tr>
			<tr><td>Math.cos(x)</td><td>餘弦。</td></tr>
			<tr><td>Math.cosh(x)</td><td>雙曲餘弦。</td></tr>
			<tr><td>Math.exp(x)</td><td>e 的 X 次方。</td></tr>
			<tr><td>Math.expm1(x)</td><td>e - 1 的 X 次方。</td></tr>
			<tr><td>Math.floor(x)</td><td>無條件捨去。</td></tr>
			<tr><td>Math.fround(x)</td><td>用浮點數四捨五入。</td></tr>
			<tr><td>Math.hypot(x,…)</td><td>平方和的平方根。</td></tr>
			<tr><td>Math.imul(x,y)</td><td>32 位元整數相乘。</td></tr>
			<tr><td>Math.log(x)</td><td>自然對數。</td></tr>
			<tr><td>Math.log10(x)</td><td>底數為 10 的對數</td></tr>
			<tr><td>Math.log1p(x)</td><td>X+1 的自然對數。</td></tr>
			<tr><td>Math.log2(x)</td><td>底數為 2 的對數。</td></tr>
			<tr><td>Math.max(x,y,z,…)</td><td>傳回最大的那個參數值。</td></tr>
			<tr><td>Math.min(x,y,z,…)</td><td>傳回最小的那個參數值。</td></tr>
			<tr><td>Math.pow(x,y)</td><td>X 的 Y 次方。</td></tr>
			<tr><td>Math.random()</td><td>隨機取得 0 到 1 之間的小數。</td></tr>
			<tr><td>Math.round(x)</td><td>四捨五入。</td></tr>
			<tr><td>Math.sign(x)</td><td>是正數傳回 1、負數 -1、正零 0、負零 -0。</td></tr>
			<tr><td>Math.sin(x)</td><td>正弦。</td></tr>
			<tr><td>Math.sinh(x)</td><td>雙曲正弦。</td></tr>
			<tr><td>Math.sqrt(x)</td><td>平方根。</td></tr>
			<tr><td>Math.tan(x)</td><td>正切。</td></tr>
			<tr><td>Math.tanh(x)</td><td>雙曲正切。</td></tr>
			<tr><td>Math.trunc(x)</td><td>去掉小數，只留整數。</td></tr>
			<tr><td>Math.E</td><td>自然對數的底數。</td></tr>
			<tr><td>Math.LN10</td><td>10 的自然對數。</td></tr>
			<tr><td>Math.LN2</td><td>2 的自然對數。</td></tr>
			<tr><td>Math.LOG10E</td><td>以 10 為底數 e 的對數。</td></tr>
			<tr><td>Math.LOG2E</td><td>以 2 為底數 e 的對數。</td></tr>
			<tr><td>Math.PI</td><td>圓周率。</td></tr>
			<tr><td>Math.SQRT1_2</td><td>根號 2 分之 1。</td></tr>
			<tr><td>Math.SQRT2</td><td>根號 2。</td></tr>
		</table>
		<p>
			大多是直接套用的數學函數，只有 random() 的使用比較複雜，需要另外說明！它是我們取得「亂數」的管道，但它傳回的值是小數點達十幾個位數、介於 0.0 到 1.0 之間，所以如果不另外處理的話，傳回來的值不適合我們使用。<br>
			<br>
			通常我們取得亂數的情況希望是整數，因此常見的用法是使用四捨五入的方式來處理 random() 的值……<br>
			<br>
			<samp>Math.round(Math.random()*(最大值-最小值))+最小值</samp><br>
			<br>
			如果你需要傳回 3 到 9 之間的亂數，就是：<br>
			<br>
			<textarea class='brush:js'>
				Math.round(Math.random()*(9-3))+3;
            </textarea>
			<br>
			除了使用四捨五入的 round()，有時候會想使用無條件進位的 ceil() 或無條件捨去的 floor()，差異如下：<br>
			<br>
			<textarea class='brush:js'>
				Math.round(Math.random()*10); //四捨五入：傳回 0 到 10。
				Math.ceil(Math.random()*10);  //無條件進位：傳回 1 到 10。
				Math.floor(Math.random()*10); //無條件捨去：傳回 0 到 9。
            </textarea>
			<br>
			當你希望產生的亂數直接對照陣列索引值，就適合直接用 floor()：<br>
			<br>
			<textarea class='brush:js'>
				document.write(['剪刀','石頭','布'][Math.floor(Math.random()*3)]);
            </textarea>
		</p>
	</section>
	<hr id='number'>
	<section>
		<h2>Number</h2>
		<p>
			Number 物件可以直接決定數值資料的輸出方式。在 JavaScript 我們稍不留意，資料容易就會轉為字串來處理，使用 Number 物件來確保使用數值資料。
		</p>
		<table>
			<tr><td>toExponential(小數位數)</td><td>將資料以指數形式輸出。</td></tr>
			<tr><td>toFixed(小數位數)</td><td>將資料以小數點的形式輸出。</td></tr>
			<tr><td>toPrecision(保留位數)</td><td>設定保留的位數來輸出資料。</td></tr>
			<tr><td>Number.siFinite(資料)</td><td>檢查資料是否為無限大。</td></tr>
			<tr><td>Number.siInteger(資料)</td><td>檢查資料是否為整數。</td></tr>
			<tr><td>Number.siNaN(資料)</td><td>檢查資料是否為 NaN。</td></tr>
			<tr><td>Number.siSafeInteger(資料)</td><td>檢查資料是否為安全精度範圍的整數。</td></tr>
			<tr><td>Number.EPSILON</td><td>傳回 ε 常數。</td></tr>
			<tr><td>Number.MAX_SAFE_INTEGER</td><td>傳回安全精度範圍內的最大數值。</td></tr>
			<tr><td>Number.MAX_VALUE</td><td>傳回 JavaScript 所能接受的最大數值。</td></tr>
			<tr><td>Number.MIN_SAFE_INTEGER</td><td>傳回安全精度範圍內的最小數值。</td></tr>
			<tr><td>Number.MIN_VALUE</td><td>傳回 JavaScript 所能接受的最小數值。</td></tr>
			<tr><td>Number.NaN</td><td>Not a number。</td></tr>
			<tr><td>Number.NEGATIVE_INFINITY</td><td>負無限大。</td></tr>
			<tr><td>Number.POSITIVE_INFINITY</td><td>無限大。</td></tr>
		</table>
	</section>
	<hr id='object'>
	<section>
		<h2>Object</h2>
		<p>
			所有物件都會繫結 Object 的 prototype，因此 Object 最主要作用，就是在內部做為其它物件的共通功能！像是所有物件都能以 toString() 輸出資料、都能以 valueOf() 將資料轉換成各自己型態的資料、都能以 constructor 做為 class 語法的建構式。<br>
			<br>
			其次是以 Object. 開頭的功能，方便外部使用者組織程式碼，讓 JavaScript 這門動態型別的物件導向語言，也能有效管理大量程式碼。
		</p>
		<table>
			<tr><td style='width:55%'>constructor</td><td>建構式。</td></tr>
			<tr><td>hasOwnProperty(屬性)</td><td>檢查是否有自己的屬性，非繼承而來。</td></tr>
			<tr><td>isPrototypeOf(物件)</td><td>檢查物件是否在原型鏈中。</td></tr>
			<tr><td>name</td><td>傳回物件名稱。</td></tr>
			<tr><td>propertyIsEnumerable(屬性)</td><td>檢查屬性是否可迭代。</td></tr>
			<tr><td>prototype</td><td>原型。</td></tr>
			<tr><td>toString()</td><td>以字串輸出資料。</td></tr>
			<tr><td>valueOf(物件)</td><td>轉換為物件型態的資料。</td></tr>
			<tr><td>Object.assign(物件,物件)</td><td>將物件合併並傳回新物件。</td></tr>
			<tr><td>Object.create(物件)</td><td>複製新的物件。</td></tr>
			<tr><td>Object.defineProperites(物件,屬性群)</td><td>用 object literal 定義屬性。</td></tr>
			<tr><td>Object.defineProperty(物件,屬性,值)</td><td>用 object literal 定義一個屬性。</td></tr>
			<tr><td>Object.entries()</td><td>以鍵值對取得所有屬性。</td></tr>
			<tr><td>Object.freeze(物件)</td><td>禁止物件被複製。</td></tr>
			<tr><td>Object.fromEntries(物件)</td><td>將鍵值對資料轉為物件。</td></tr>
			<tr><td>Object.getOwnPropertyDescriptor(物件)</td><td>取得自有屬性的描述。</td></tr>
			<tr><td>Object.getOwnPropertyDescriptors(物件)</td><td>取得自有屬性的描述。</td></tr>
			<tr><td>Object.getOwnPropertyNames(物件)</td><td>取得自有屬性的名稱。</td></tr>
			<tr><td>Object.getOwnPropertySymbols(物件)</td><td>取得自有屬性的內容。</td></tr>
			<tr><td>Object.getPrototypeOf(物件)</td><td>取得物件的原型。</td></tr>
			<tr><td>Object.hasOwn(屬性)</td><td>檢查是否有自己的屬性，非繼承而來。</td></tr>
			<tr><td>Object.is(物件值,物件值)</td><td>檢查兩個值是否連型別也相同。</td></tr>
			<tr><td>Object.isExtensible(物件)</td><td>檢查物件是否為 preventExtensions() 狀態。</td></tr>
			<tr><td>Object.isFrozen(物件)</td><td>檢查物件是否為 freeze() 狀態。</td></tr>
			<tr><td>Object.isSealed(物件)</td><td>檢查物件是否為 seal() 狀態。</td></tr>
			<tr><td>Object.keys()</td><td>取得所有屬性名稱。</td></tr>
			<tr><td>Object.preventExtensions(物件)</td><td>禁止物件被增加屬性和功能。</td></tr>
			<tr><td>Object.seal(物件)</td><td>禁止物件被增刪屬性和功能。</td></tr>
			<tr><td>Object.setPrototypeOf(原型,物件)</td><td>設定原型為另一個物件。</td></tr>
			<tr><td>Object.values()</td><td>取得所有屬性值。</td></tr>
		</table>
		<p>
			Object 有多好用，看了範例就知道，簡直能讓人下出一手神乎其技：<br>
			<br>
			<textarea class='brush:js'>
				Object.prototype.br=function(){
					document.write(`${this}&lt;br&gt;`);
				};

				'abc'.br();   //String
				(123).br();   //Number
				[1,2,3].br(); //Array
            </textarea>
			<br>
			<output>
				abc<br>
				123<br>
				1,2,3
			</output>
		</p>
	</section>
	<hr id='promise'>
	<section>
		<h2>Promise</h2>
		<p>
			 用來設計非同步（asynchronous）執行的程式。
		</p>
		<table>
			<tr><td>all(iterable)</td><td>iterable 全都 resolved 的話傳回 Promise。</td></tr>
			<tr><td>allSettled(iterable)</td><td>iterable 全都 settled 的話傳回 Promise。</td></tr>
			<tr><td>any(iterable)</td><td>iterable 有 resolved 的話傳回 Promise。</td></tr>
			<tr><td>catch(onRejected)</td><td>有觸發 onRejected 的話傳回 Promise。</td></tr>
			<tr><td>finally(onFinally)</td><td>有觸發 onFinally 的話傳回 Promise。</td></tr>
			<tr><td>race(iterable)</td><td>無論 iterable 有 resolved 或 reason 都傳回 Promise。</td></tr>
			<tr><td>reject(reason)</td><td>reason 的話傳回 Promise 物件。</td></tr>
			<tr><td>resolve(value)</td><td>value 是 thenable 的話傳回 Promise。</td></tr>
			<tr><td>then(onFulfilled[,onRejected])</td><td>產生 Promise 時執行回呼函式。</td></tr>
		</table>
		<p>
			在 JavaScript 3 時代，想另外開一個執行序來進行非同步運算，都是用 setTimeout()。但 setTimeout() 把要執行的程式寫在回呼函式裡，當非同步運算複雜到一條又一條的執行序，會導致一層又一層的回呼函式：<br>
			<br>
			<textarea class='brush:js'>
				setTimeout(function(){
					setTimeout(function(){
						setTimeout(function(){
							setTimeout(function(){
								//一場回呼地獄災難
							},200);
						},200);
					},200);
				},200);
            </textarea>
			<br>
			Promise 可以用串接一個又一個 then() 函式解決回呼地獄的問題：<br>
			<br>
			<textarea class='brush:js'>
				let promise = new Promise(/*這裡先省略 executor 函式*/);
				promise.then(function(){})
					   .then(function(){})
					   .then(function(){})
					   .then(function(){});
            </textarea>
			<br>
			注意！Promise 並不是執行序，它本身並沒有執行序的功能，Promise API 是用來為非同步程式設計制定一個上下文語義的框架，畢竟就本文所舉的例子，執行序只是用來設計非同步運算的一個手段。所以它不叫 Thread，而叫 Promise，它可用來表示非同步運算結果為成功或失敗。如果你需要的是比 setTimeout() 和 setInterval() 更正式一點的執行序，可以用 Web worker。<br>
			<br>
			底下範例會在三秒後輸出 Hello! 訊息：<br>
			<br>
			<textarea class='brush:js'>
				let promise = new Promise((resolve,reject)=>{
					setTimeout(()=>{
						resolve('Hello!');
					},3000);
				});
				promise.then(console.log);
            </textarea>
			<br>
			Promise() 建構函式可接受兩個參數，第一個用在有結果的情況，通常參數名稱取為 resolve，第二個用在沒有結果的情況，通常參數名稱取為 reject。範例只對有結果的情況做出反應，沒有結果的話其實可以進一步除錯或防呆。<br>
			<br>
			then() 會在 Promise 送出 resolve() 的情況下有反應，它會獲得 resolve() 傳回的值，並將它傳入第一個參數，運作完會再將 Promise 本身傳回，也就是再度獲得同一個 Promise，這也是 then() 可以串接的原因，能持續對同一個 Promise 做出反應。<br>
			<br>
			就像 resolve 對應 then()，reject 的話可以用 catch() 來做反應。<br>
			<br>
			除了用建構函式設計非同步程式，也可以直接用 Promise.resolve() 和 Promise.reject() 產生有結果的 Promise 和沒有結果的 Promise：<br>
			<br>
			<textarea class='brush:js'>
				Promise.resolve('Bye').then(console.log);
            </textarea>
		</p>
	</section>
	<hr id='regexp'>
	<section>
		<h2>RegExp</h2>
		<p>
			RegExp 物件用來實現 Regular Expressions，這是一種強大的字元匹配機制。
		</p>
		<table>
			<tr><td>exec(正規式)</td><td>匹配正規式，成立的話傳回資料。</td></tr>
			<tr><td>flags</td><td>取得 d g i m s u y 設定狀態。</td></tr>
			<tr><td>test(正規式)</td><td>匹配正規式，成立傳回 true，否則 false。</td></tr>
		</table>
		<p>
			還有 hasIndices、global、ignoreCae、multiline、dotAll、unicode、sticky 屬性沒列出來，這是因為通常要設定這些狀態的話，不如改用 <code>/正規式/dgimsuy</code> 這語法糖來簡化 RegExp 的操作。
		</p>
	</section>
	<hr id='set'>
	<section>
		<h2>Set</h2>
		<p>
			集合資料結構，與 Array 的差別在於資料不會重複，且迭代性能提高。
		</p>
		<table>
			<tr><td>add(值)</td><td>加入資料。</td></tr>
			<tr><td>clear()</td><td>清除所有資料。</td></tr>
			<tr><td>delete(值)</td><td>刪除一筆資料。</td></tr>
			<tr><td>forEach(回呼函式)</td><td>隨資料的列舉過程執行程式功能。</td></tr>
			<tr><td>has(值)</td><td>檢查是否有某筆資料。</td></tr>
			<tr><td>size</td><td>取得資料筆數。</td></tr>
			<tr><td>values()</td><td>以 Iterator 傳回所有資料。</td></tr>
		</table>
		<p>
			Set 雖然也有 entries() 和 keys()，但那是為了能和混用 Map() 防錯用的。<br>
			<br>
			來看個有趣的範例：<br>
			<br>
			<textarea class='brush:js'>
				let set=new Set([2,0,1,2,1,2,2,1]); //陣列轉集合
				let array=[...set]; //集合轉陣列

				document.write(array);
            </textarea>
			<br>
			<output>
				2,0,1
			</output>
		</p>
	</section>
	<hr id='string'>
	<section>
		<h2>String</h2>
		<p>
			String 物件可以對「文字資料」進行多種操作，例如：搜尋、替換、擷取。
		</p>
		<table>
			<tr><td>at(字元位置)</td><td>傳回指定位置的字元，允許負號倒數。</td></tr>
			<tr><td>charAt(字元位置)</td><td>傳回指定位置的字元。</td></tr>
			<tr><td>charCodeAt(字元位置)</td><td>以 UTF-16 傳回指定位置字元的 Unicode 編碼。</td></tr>
			<tr><td>codePointAt(字元位置)</td><td>傳回指定位置字元的 Unicode 編碼。</td></tr>
			<tr><td>concat(字串,字串,…)</td><td>將多個字串結合成一串。</td></tr>
			<tr><td>endsWith(文字)</td><td>字串是否以文字結尾。</td></tr>
			<tr><td>inclueds(文字)</td><td>檢查是否包含文字。</td></tr>
			<tr><td>indexOf(比對字串)</td><td>比對是否出現所指定的字串，並傳回找到的字元位置。</td></tr>
			<tr><td>isWellFormed()</td><td>檢查字串是否完全 Uncicode 而非 UTF-16。</td></tr>
			<tr><td>lastIndexOf(比對字串)</td><td>類似 indexOf()，但由後往前找。</td></tr>
			<tr><td>length</td><td>取得文字的長度。</td></tr>
			<tr><td>localeCompare(字串)</td><td>很難說明，請看 <a href='http://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare'>MDN</a> 的範例比較快。</td></tr>
			<tr><td>match(正規表示法)</td><td>比對 RegExp 條件，有的話傳回找到的資料。</td></tr>
			<tr><td>matchAll(正規表示法)</td><td>比對 RegExp 條件，有的話傳回找到的資料。</td></tr>
			<tr><td>normalize('NFD'|'NFKC'|'NFKD')</td><td>指定格式傳回 Uncicode 字串，不指定的話為 'NFC'。</td></tr>
			<tr><td>padEnd(長度[,文字])</td><td>字數不足時，在尾端填上文字。</td></tr>
			<tr><td>padStart(長度[,文字])</td><td>字數不足時，在頭端填上文字。</td></tr>
			<tr><td>repeat(次數)</td><td>以次數複製字串。</td></tr>
			<tr><td>replace(正規表示法,替代字串)</td><td>比對 RegExp 條件，有的話改為替代文字並傳回資料。</td></tr>
			<tr><td>replaceAll(正規表示法,替代字串)</td><td>比對 RegExp 條件，有的話改為替代文字並傳回資料。</td></tr>
			<tr><td>search(正規表示法)</td><td>比對 RegExp 條件，有的話傳回找到的位置。</td></tr>
			<tr><td>slice(開始位置,結束位置)</td><td>擷取範圍內的字串，結束位置可用負數表示倒數。</td></tr>
			<tr><td>split(分割點,區段)</td><td>以分割點作依據，將字串切成好幾個區段。區段可省略。</td></tr>
			<tr><td>startsWith(文字)</td><td>字串是否以文字開頭。</td></tr>
			<tr><td>substr(開始位置,長度)</td><td>從指定位置開始擷取指定長度的字串。</td></tr>
			<tr><td>substring(位置,位置)</td><td>擷取位置到位置範圍內的字串，兩位置大小順序可顛倒。</td></tr>
			<tr><td>toLowerCase()</td><td>將英文字母以小寫輸出。</td></tr>
			<tr><td>toUpperCase()</td><td>將英文字母以大寫輸出。</td></tr>
			<tr><td>toWellFormed()</td><td>以完全 Unicode 編碼輸出字串，而不是以 UTF-16 方式進行。</td></tr>
			<tr><td>trim()</td><td>刪除頭尾兩端空白。</td></tr>
			<tr><td>trimEnd()</td><td>刪除尾端空白。</td></tr>
			<tr><td>trimStart()</td><td>刪除頭端空白。</td></tr>
			<tr><td>String.fromCharCode(字元編碼,…)</td><td>以 UTF-16 輸出 Unicode 編碼對應的字元。</td></tr>
			<tr><td>String.fromCodePoint(字元編碼,…)</td><td>輸出 Unicode 編碼對應的字元。</td></tr>
			<tr><td>String.raw`字串`</td><td>Template literal。</td></tr>
		</table>
		<p>
			JavaScript 的字串使用 UTF-16，不夠處理完整的 Unicode 編碼，於是追加 code point 和 well formed 等做法解決問題。<br>
			<br>
			substr() 並不是標準，但它往往比 substring() 好用而被廣泛使用，於是規格書刻意 deprecated 說不建議使用這項功能。對此我的想法是，就算有哪個程式引擎沒實作 substr()，我也會自己加到 String.prototype，沒理由不用它 (●'◡'●)
		</p>
		<hr>
		<section>
			<h3>非標準功能：以 HTML 4.01 格式輸出文字</h3>
			<table>
				<tr><td>anchor()</td><td>將文字以 &lt;A NAME&gt;&lt;/A&gt; 格式輸出</td></tr>
				<tr><td>big()</td><td>將文字以 &lt;BIG&gt;&lt;/BIF&gt; 格式輸出</td></tr>
				<tr><td>blink()</td><td>將文字以 &lt;BLNK&gt;&lt;/BLINK&gt; 格式輸出</td></tr>
				<tr><td>bold()</td><td>將文字以 &lt;B&gt;&lt;/B&gt; 格式輸出</td></tr>
				<tr><td>fixed()</td><td>將文字以 &lt;TT&gt;&lt;/TT&gt; 格式輸出</td></tr>
				<tr><td>fontcolor()</td><td>將文字以 &lt;FONT COLOR=''&gt;&lt;/FONT&gt; 格式輸出</td></tr>
				<tr><td>fontsize()</td><td>將文字以 &lt;FONT SIZE=''&gt;&lt;/FONT&gt; 格式輸出</td></tr>
				<tr><td>italics()</td><td>將文字以 &lt;I&gt;&lt;/I&gt; 格式輸出</td></tr>
				<tr><td>link()</td><td>將文字以 &lt;A HREF=''&gt;&lt;/A&gt; 格式輸出</td></tr>
				<tr><td>small()</td><td>將文字以 &lt;SMALL&gt;&lt;/SMALL&gt; 格式輸出</td></tr>
				<tr><td>strike()</td><td>將文字以 &lt;STRIKE&gt;&lt;/STRIKE&gt; 格式輸出</td></tr>
				<tr><td>sub()</td><td>將文字以 &lt;SUB&gt;&lt;/SUB&gt; 格式輸出</td></tr>
				<tr><td>sup()</td><td>將文字以 &lt;SUP&gt;&lt;/SUP&gt; 格式輸出</td></tr>
			</table>
			<p>
				坦白說，把網頁當 GUI 寫應用程式時，這些 deprecated 的功能蠻好用的，程式碼很優雅，我甚至想自行追加更多這樣的輸出函式來用 (๑•̀ㅂ•́)و✧
			</p>
		</section>
	</section>
	<hr id='url'>
	<section>
		<h2>URL</h2>
		<p>
			URL 能在從網址中取得通訊行定、域名、埠號、標識，以及夾帶的參數資料。
		</p>
		<table>
			<tr><td>hash</td><td>傳回 # 的標識（fragment）</td></tr>
			<tr><td>host</td><td>傳回域名和埠號</td></tr>
			<tr><td>hostname</td><td>傳回域名</td></tr>
			<tr><td>href</td><td>傳回完整網址</td></tr>
			<tr><td>pathname</td><td>傳回資料夾和檔案的路徑字串</td></tr>
			<tr><td>port</td><td>傳回埠號</td></tr>
			<tr><td>protocol</td><td>傳回通訊協定</td></tr>
			<tr><td>search</td><td>傳回 ? 的參數</td></tr>
			<tr><td>searchParams</td><td>傳回 URLSearchParams 物件，可用 get() 直接取得參數。</td></tr>
		</table>
		<p>
			你很難不喜歡這個功能：<br>
			<br>
			<textarea class='brush:js'>
				let url=new URL('http://localhost/exec.html?command=notepad');
				document.write(url.searchParams.get('command'));
            </textarea>
			<br>
			<output>
				notepad
			</output>
			<br>
			進一步把 window.location 傳給 URL()，就能取得網頁夾帶的參數資料。
		</p>
	</section>
</article>